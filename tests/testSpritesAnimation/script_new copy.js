    var canvas;
    var stage;
    var screen_width;
    var screen_height;
    var bmpAnimation = [];
    var bmpAnimationIdle = [];
    var animCount = 10;

    var numberOfImagesLoaded = 0;

    var imgMonsterARun = new Image();
    var imgMonsterAIdle = new Image();

    function init() {
        //find canvas and load images, wait for last image to load
        canvas = document.getElementById("testCanvas");

        imgMonsterARun.onload = handleImageLoad;
        imgMonsterARun.onerror = handleImageError;
        imgMonsterARun.src = "img/MonsterARun.png";

        imgMonsterAIdle.onload = handleImageLoad;
        imgMonsterAIdle.onerror = handleImageError;
        imgMonsterAIdle.src = "img/MonsterAIdle.png";
    }

    function handleImageLoad(e) {
        numberOfImagesLoaded++;

        // We're not starting the game until all images are loaded
        // Otherwise, you may start to draw without the resource and raise
        // this DOM Exception: INVALID_STATE_ERR (11) on the drawImage method
        if (numberOfImagesLoaded == 2) {
            numberOfImagesLoaded = 0;
            startGame();
        }
    }

    function reset() {
        stage.removeAllChildren();
        createjs.Ticker.removeAllListeners();
        stage.update();
    }

function startGame() {
        // create a new stage and point it at our canvas:
        stage = new createjs.Stage(canvas);

        // grab canvas width and height for later calculations:
        screen_width = canvas.width;
        screen_height = canvas.height;
	var i=1;
	for(i=1; i<animCount+1; i++) {
        // create spritesheet and assign the associated data.
			
        var spriteSheet = new createjs.SpriteSheet({
            //image to use
            images: [imgMonsterARun],
            //width, height & registration point of each sprite
            frames: { width: 64, height: 64, regX: 32, regY: 32 }, 
            // To slow down the animation loop of the sprite, we set the frequency to 4 to slow down by a 4x factor
            animations: {
                walk: [0, 9, "walk", 4]
            }
        });

        // to save file size, the loaded sprite sheet only includes left facing animations
        // we could flip the display objects with scaleX=-1, but this is expensive in most browsers
        // instead, we generate a new sprite sheet which includes the flipped animations
        createjs.SpriteSheetUtils.addFlippedFrames(spriteSheet, true, false, false);

        // Idle sequence of the monster
        var spriteSheetIdle = new createjs.SpriteSheet({
            images: [imgMonsterAIdle],
            frames: { width: 64, height: 64, regX: 32, regY: 32 }, 
            animations: {
                idle: [0, 10, "idle", 4]
            }
        });

        bmpAnimationIdle[i] = new createjs.BitmapAnimation(spriteSheetIdle);
        var rYI = 64 * i - 32;

        bmpAnimationIdle[i].name = "monsteridle1";
        bmpAnimationIdle[i].x = 16;
        bmpAnimationIdle[i].y = rYI;

        // create a BitmapSequence instance to display and play back the sprite sheet:
        bmpAnimation[i] = new createjs.BitmapAnimation(spriteSheet);

        // set the registration point (the point it will be positioned and rotated around)
        // to the center of the frame dimensions:
        bmpAnimation[i].regX = bmpAnimation[i].spriteSheet.frameWidth / 2 | 0;
        var rY = bmpAnimation[i].spriteSheet.frameHeight * i - (bmpAnimation[i].spriteSheet.frameHeight / 2);
        bmpAnimation[i].regY = rY | 0;

        // start playing the first sequence:
        // walk_h has been generated by addFlippedFrames and
        // contained the right facing animations
        bmpAnimation[i].gotoAndPlay("walk_h"); 	//walking from left to right

        // set up a shadow. Note that shadows are ridiculously expensive. You could display hundreds
        // of animated rats if you disabled the shadow.
        bmpAnimation[i].shadow = new createjs.Shadow("#454", 0, 5, 4);

        bmpAnimation[i].name = "monster1";
        bmpAnimation[i].direction = 90;
        bmpAnimation[i].vX = 1;
        bmpAnimation[i].vY = 0;
        bmpAnimation[i].x = 16;
        bmpAnimation[i].y = 64 * i - 32;

        // have each monster start at a specific frame
        bmpAnimation[i].currentFrame = 10;
        stage.addChild(bmpAnimation[i]);
	}
	// we want to do some work before we update the canvas,
	// otherwise we could use Ticker.addListener(stage);
	createjs.Ticker.addListener(window);
	createjs.Ticker.useRAF = true;
	// Best Framerate targeted (60 FPS)
	createjs.Ticker.setFPS(60);
}

    //called if there is an error loading the image (usually due to a 404)
    function handleImageError(e) {
        console.log("Error Loading Image : " + e.target.src);
    }

function tick() {
	for(i=1; i<animCount+1; i++) {
	        // Hit testing the screen width, otherwise our sprite would disappear
        if (bmpAnimation[i].x >= screen_width - 16) {
            // We've reached the right side of our screen
            // We need to walk left now to go back to our initial position
            bmpAnimation[i].direction = -90;
            bmpAnimation[i].gotoAndPlay("walk")
        }

        if (bmpAnimation[i].x < 16) {
            // We've reached the left side of our screen
            // We need to walk right now
            bmpAnimation[i].direction = 90;
            bmpAnimation[i].gotoAndStop("walk");
            stage.removeChild(bmpAnimation[i]);
            bmpAnimationIdle[i].gotoAndPlay("idle");
            stage.addChild(bmpAnimationIdle[i]);
        }

        // Moving the sprite based on the direction & the speed
        if (bmpAnimation[i].direction == 90) {
            bmpAnimation[i].x += bmpAnimation[i].vX;
            bmpAnimation[i].y += bmpAnimation[i].vY;
        }
        else {
            bmpAnimation[i].x -= bmpAnimation[i].vX;
            bmpAnimation[i].y -= bmpAnimation[i].vY;
        }
	}
        // update the stage:
        stage.update();
}
//            var debugP=document.getElementById("debug")
//			debugP.innerHTML="y=" + y;
