    var canvas;
    var stage;
    var screen_width;
    var screen_height;
    var bmpAnimation = [];
    var rowCount = 5;
    var itemsPerRow = 10;
    var shadowEnabled = false;

    var numberOfImagesLoaded = 0;

    var imgMonsterARun = new Image();
    var imgMonsterAIdle = new Image();

    function init() {
        //find canvas and load images, wait for last image to load
        canvas = document.getElementById("testCanvas");

        imgMonsterARun.onload = handleImageLoad;
        imgMonsterARun.onerror = handleImageError;
        imgMonsterARun.src = "img/MonsterARun.png";

        imgMonsterAIdle.onload = handleImageLoad;
        imgMonsterAIdle.onerror = handleImageError;
        imgMonsterAIdle.src = "img/MonsterAIdle.png";
        if (numberOfImagesLoaded == 2) {
	        startGame();
        }
    }

    function handleImageLoad(e) {
        numberOfImagesLoaded++;

        // We're not starting the game until all images are loaded
        // Otherwise, you may start to draw without the resource and raise
        // this DOM Exception: INVALID_STATE_ERR (11) on the drawImage method
        if (numberOfImagesLoaded == 2) {
//            numberOfImagesLoaded = 0;
            startGame();
        }
    }

    function reset() {
        stage.removeAllChildren();
        createjs.Ticker.removeAllListeners();
        stage.update();
    }

function startGame() {
	itemsPerRow = document.getElementById('itemCount').value;
	shadowEnabled = document.getElementById('shadow').checked;
        // create a new stage and point it at our canvas:
        stage = new createjs.Stage(canvas);

        // grab canvas width and height for later calculations:
        screen_width = canvas.width;
        screen_height = canvas.height;
//        rowCount = screen_height/64;
	for(var i=0; i<rowCount; i++) {
		for(var j=0; j<itemsPerRow;j++) {
			var spriteSheet = new createjs.SpriteSheet({
				//image to use
				images: [imgMonsterARun],
				//width, height & registration point of each sprite
				frames: { width: 64, height: 64, regX: 32, regY: 32 }, 
				animations: {
					walk: [0, 9, "walk", 3]
				}
			});
	
			// to save file size, the loaded sprite sheet only includes left facing animations
			// we could flip the display objects with scaleX=-1, but this is expensive in most browsers
			// instead, we generate a new sprite sheet which includes the flipped animations
			createjs.SpriteSheetUtils.addFlippedFrames(spriteSheet, true, false, false);
	
			// create a BitmapSequence instance to display and play back the sprite sheet:
			bmpAnimation[i*itemsPerRow + j] = new createjs.BitmapAnimation(spriteSheet);
	
			// set the registration point (the point it will be positioned and rotated around)
			// to the center of the frame dimensions:
			bmpAnimation[i*itemsPerRow + j].regX = bmpAnimation[i*itemsPerRow + j].spriteSheet.frameWidth / 2 | 0;
			bmpAnimation[i*itemsPerRow + j].regY = bmpAnimation[i*itemsPerRow + j].spriteSheet.frameHeight / 2 | 0;
	
			// start playing the first sequence:
			// walk_h has been generated by addFlippedFrames and
			// contained the right facing animations
			bmpAnimation[i*itemsPerRow + j].gotoAndPlay("walk_h"); 	//walking from left to right
	
			// set up a shadow. Note that shadows are ridiculously expensive. You could display hundreds
			// of animated rats if you disabled the shadow.
			if (shadowEnabled) {
				bmpAnimation[i*itemsPerRow + j].shadow = new createjs.Shadow("#454", 0, 5, 4);
			}
	
			bmpAnimation[i*itemsPerRow + j].name = "monster1";
			bmpAnimation[i*itemsPerRow + j].direction = 90;
			bmpAnimation[i*itemsPerRow + j].vX = 1 + j/4 + i/2;
			bmpAnimation[i*itemsPerRow + j].vY = 0;
			bmpAnimation[i*itemsPerRow + j].x = 32 + 64 * (j) + i*8;
			bmpAnimation[i*itemsPerRow + j].y = 64 * (i+1) - 32;
			// have each monster start at a specific frame
			bmpAnimation[i*itemsPerRow + j].currentFrame = 10;
			stage.addChild(bmpAnimation[i*itemsPerRow + j]);
        }
	}
	// we want to do some work before we update the canvas,
	// otherwise we could use Ticker.addListener(stage);
	createjs.Ticker.addListener(window);
	createjs.Ticker.useRAF = true;
	// Best Framerate targeted (60 FPS)
	createjs.Ticker.setFPS(60);
}

    //called if there is an error loading the image (usually due to a 404)
    function handleImageError(e) {
        console.log("Error Loading Image : " + e.target.src);
    }

function tick(elapsedTime, paused) {
	for(var i=0; i<rowCount; i++) {
		for(var j=0; j<itemsPerRow;j++) {
				// Hit testing the screen width, otherwise our sprite would disappear
			if (bmpAnimation[i*itemsPerRow + j].x >= screen_width - 16) {
				// We've reached the right side of our screen
				// We need to walk left now to go back to our initial position
				bmpAnimation[i*itemsPerRow + j].direction = -90;
				bmpAnimation[i*itemsPerRow + j].gotoAndPlay("walk")
			}
	
			if (bmpAnimation[i*itemsPerRow + j].x < 32) {
				// We've reached the left side of our screen
				// We need to walk right now
				bmpAnimation[i*itemsPerRow + j].direction = 90;
				bmpAnimation[i*itemsPerRow + j].gotoAndPlay("walk_h");
			}
	
			// Moving the sprite based on the direction & the speed
			if (bmpAnimation[i*itemsPerRow + j].direction == 90) {
				bmpAnimation[i*itemsPerRow + j].x += bmpAnimation[i*itemsPerRow + j].vX;
				bmpAnimation[i*itemsPerRow + j].y += bmpAnimation[i*itemsPerRow + j].vY;
			}
			else {
				bmpAnimation[i*itemsPerRow + j].x -= bmpAnimation[i*itemsPerRow + j].vX;
				bmpAnimation[i*itemsPerRow + j].y -= bmpAnimation[i*itemsPerRow + j].vY;
			}
		}
	}
        // update the stage:
        stage.update();
    showFPS(elapsedTime);
}

var second = 0;
  function showFPS(elapsedTime) {
    second += elapsedTime;
    if (second > 1000) {
      document.getElementById('fps').innerHTML = Math.round(createjs.Ticker.getMeasuredFPS());
      second = 0;
    }
  }

